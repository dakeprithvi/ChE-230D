# -*- coding: utf-8 -*-
"""Learning from batch reactor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Aq2naRh-4Gt3aMHR06WKpFG4V5wWn3rR
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.optimize
import scipy.linalg

# Basecase data generating model
# stoichiometry matrix
v = np.array([[-1,2,0],[0,-1,1]])
# rate constants
k = np.array([[1,-1/3,0],[0,0.1,0]])
Kmodel = np.dot(v.T,k)
K = Kmodel
# initial conditions
c0 = np.array([[1,0,0]])
num_of_meas = 75
t = np.linspace(0,6,num_of_meas)
E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
E = np.transpose(E)
Ctrue = np.array([E[0][0],E[0][1],E[0][2]])
plt.plot(t,Ctrue.T);
plt.xlabel("time")
plt.ylabel("Concentration")
plt.legend(["A","B","C"])
plt.title("Basecase model")
plt.show()

#Basecase data corrupted by adding IID error to all concentration measurments
Cmeas = np.array([E[0][0],E[0][1],E[0][2]])
np.random.seed(10)
Cmeas = Cmeas + np.random.normal(0,0.075,size=(3,num_of_meas))
[plt.scatter(t, Cmeas[i]) for i in range(Cmeas.shape[0])];
plt.xlabel("time")
plt.ylabel("Concentration")
plt.legend(["A","B","C"])
plt.title("Measurement data")
plt.show()

#Jim's data from lin_kin_1.mat
#Previous Cmeas variable is now rewritten to consider this data
from scipy.io import loadmat
t = np.linspace(0,20,25)
data = loadmat('lin_kin.mat')
Cmeas = data["ymeas"]
Cmeas = Cmeas.T
[plt.scatter(t, Cmeas[i]) for i in range(Cmeas.shape[0])];
plt.xlabel("time")
plt.ylabel("Concentration")
plt.legend(["A","B","C"])
plt.title("Measurement data")
plt.show()

#Fitting model where we know mechanism
def mech_model(K):
  K = np.array([[K[0],-K[1],0],[0,K[2],0]])
  K = np.dot(v.T,K)
  E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
  E = np.transpose(E)
  Cmodel = np.array([E[0][0],E[0][1],E[0][2]])
  diff = Cmeas - Cmodel
  sqe = np.sum(np.square(diff))
  return sqe


x0 = -np.zeros(3)
result = scipy.optimize.minimize(mech_model, x0, method = "L-BFGS-B")

K = result['x']
K = np.array([[K[0],-K[1],0],[0,K[2],0]])
Kmech = np.dot(v.T,K)
K = Kmech
print("The estimated coefficient matrix is:\n" + str(K) + "\n")
print(result)

E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
E = np.transpose(E)
Cmech_model = np.array([E[0][0],E[0][1],E[0][2]])
plt.plot(t,Cmech_model.T);
[plt.scatter(t, Cmeas[i]) for i in range(Cmeas.shape[0])];
plt.xlabel("time")
plt.ylabel("Concentration")
plt.legend(["A","B","C"])
plt.title("Mech")
plt.show()

#Fitting model where we know only stoichiometry
def black_box_model(K):
  K = K.reshape((3,3))
  E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
  E = np.transpose(E)
  Cmodel = np.array([E[0][0],E[0][1],E[0][2]])
  diff = Cmeas - Cmodel
  sqe = np.sum(np.square(diff))
  return sqe


x0 = -np.zeros((3,3))
x0 = x0.flatten()
result = scipy.optimize.minimize(black_box_model, x0, method = "L-BFGS-B")

Kblack_box = result['x'].reshape((3,3))
K = Kblack_box
print("The estimated coefficient matrix is:\n" + str(K) + "\n")
print(result)

E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
E = np.transpose(E)
Cblack_box = np.array([E[0][0],E[0][1],E[0][2]])
plt.plot(t,Cblack_box.T);
[plt.scatter(t, Cmeas[i]) for i in range(Cmeas.shape[0])];
plt.xlabel("time")
plt.ylabel("Concentration")
plt.legend(["A","B","C"])
plt.title("Black_box")
plt.show()

#Fitting model where we know nothing except number of species
def stoi_model(K):
  K = K.reshape((2,3))
  K = np.dot(v.T,K)
  E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
  E = np.transpose(E)
  Cmodel = np.array([E[0][0],E[0][1],E[0][2]])
  diff = Cmeas - Cmodel
  sqe = np.sum(np.square(diff))
  return sqe


x0 = -np.zeros((2,3))
x0 = x0.flatten()
result = scipy.optimize.minimize(stoi_model, x0, method = "L-BFGS-B")

K = result['x'].reshape((2,3))
Kstoi = np.dot(v.T,K)
K = Kstoi
print("The estimated coefficient matrix is:\n" + str(K) + "\n")
print(result)

E = [np.dot(scipy.linalg.expm(K*i),c0.T) for i in t]
E = np.transpose(E)
Cstoi_model = np.array([E[0][0],E[0][1],E[0][2]])
plt.plot(t,Cstoi_model.T);
[plt.scatter(t, Cmeas[i]) for i in range(Cmeas.shape[0])];
plt.xlabel("time")
plt.ylabel("Concentration")
plt.legend(["A","B","C"])
plt.title("Stoi")
plt.show()

#Solving for a CSTR
u = np.linspace(0.01,1,500)
I = np.eye(3)
cf = np.array([[1,0,0]])
cs = [-np.dot(np.linalg.inv(Kmech - i*I),cf.T)*i for i in u]
E = np.transpose(cs)
Cmech_cstr = np.array([E[0][0],E[0][1],E[0][2]])
cs = [-np.dot(np.linalg.inv(Kstoi - i*I),cf.T)*i for i in u]
E = np.transpose(cs)
Cstoi_cstr = np.array([E[0][0],E[0][1],E[0][2]])
cs = [-np.dot(np.linalg.inv(Kblack_box - i*I),cf.T)*i for i in u]
E = np.transpose(cs)
Cblack_cstr = np.array([E[0][0],E[0][1],E[0][2]])
cs = [-np.dot(np.linalg.inv(Kmodel - i*I),cf.T)*i for i in u]
E = np.transpose(cs)
Cmodel_cstr = np.array([E[0][0],E[0][1],E[0][2]])
#Quick estimate of optimum
OP, OPi = max((val, idx) for idx, val in enumerate(Cmodel_cstr[1]))
plt.scatter(u[OPi],Cmodel_cstr[1][OPi])
plt.plot(u,Cmodel_cstr[1]);
plt.plot(u,Cmech_cstr[1]);
plt.plot(u,Cstoi_cstr[1]);
plt.plot(u,Cblack_cstr[1]);
plt.xlabel("u")
plt.ylabel("Concentration")
plt.legend(["True optimum","model","mech","stoi","black_box"])
plt.title("Model comparison")
plt.show()
